import sys
import time
 
# Try to import requests (optional)
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    print("Aviso: Biblioteca requests n√£o encontrada. Pulando teste de conectividade.")
    print("Para instalar: pip install requests")
    HAS_REQUESTS = False
 
# Try to import Selenium with helpful error messages
try:
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.chrome.service import Service
except ImportError as e:
    print("Erro: Biblioteca selenium n√£o encontrada.")
    print("Execute o comando abaixo no terminal:")
    print("pip install selenium")
    sys.exit(1)
 
# Try to import WebDriver Manager
try:
    from webdriver_manager.chrome import ChromeDriverManager
except ImportError as e:
    print("Erro: WebDriver Manager n√£o encontrado.")
    print("Execute o comando abaixo no terminal:")
    print("pip install webdriver-manager")
    print("Isso eliminar√° a necessidade de baixar o ChromeDriver manualmente!")
    sys.exit(1)
 
# Try to import additional Selenium components
try:
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
except ImportError as e:
    print("Erro: Componentes adicionais do Selenium n√£o encontrados.")
    print("Execute: pip install selenium")
    sys.exit(1)
 
# Try to import additional libraries
try:
    import pandas as pd
    import tkinter as tk
    from tkinter import filedialog
    HAS_PANDAS = True
except ImportError as e:
    print("Aviso: Pandas ou tkinter n√£o encontrados.")
    print("Execute: pip install pandas")
    HAS_PANDAS = False
 
# Try to import pyautogui
try:
    import pyautogui
    HAS_PYAUTOGUI = True
except ImportError as e:
    print("Aviso: PyAutoGUI n√£o encontrado.")
    print("Execute: pip install pyautogui")
    HAS_PYAUTOGUI = False
 
# =========================================================================
# CONFIGURA√á√ïES
# =========================================================================
 
FENIX_URL = "https://fenixflorestal.suzanonet.com.br/"
 
# =========================================================================
# FUN√á√ÉO PARA TESTAR A CONECTIVIDADE
# =========================================================================
 
def test_connectivity():
    """Testa se h√° conectividade com a internet e o site"""
    if not HAS_REQUESTS:
        print("Pulando teste de conectividade (requests n√£o instalado)")
        return True
   
    print("Testando conectividade...")
   
    # Testar conectividade geral
    try:
        response = requests.get("https://www.google.com", timeout=5, verify=False)
        print("‚úì Conectividade com a internet: OK")
    except Exception as e:
        print(f"‚ö† Aviso: Problema na conectividade geral: {e}")
        print("Tentando prosseguir mesmo assim...")
        return True  # Continuar mesmo com problema
   
    # Testar conectividade com o site espec√≠fico  
    try:
        response = requests.get(FENIX_URL, timeout=10, verify=False)
        print(f"‚úì Conectividade com {FENIX_URL}: OK")
        return True
    except Exception as e:
        print(f"‚ö† Aviso: Problema ao acessar {FENIX_URL}: {e}")
        print("Tentando abrir no navegador mesmo assim...")
        return True  # Continuar mesmo com problema
 
# =========================================================================
# NAVEGA√á√ÉO E PROCESSAMENTO
# =========================================================================
 
def navigate_to_upload_section(driver, wait):
    """Navega para a se√ß√£o de upload de laudos"""
    try:
        print("\n" + "="*50)
        print("NAVEGANDO PARA SE√á√ÉO DE UPLOAD")
        print("="*50)
       
        # Aguardar e clicar em "Submiss√£o de Laudos"
        print("Procurando bot√£o 'Submiss√£o de Laudos'...")
        submissao_button = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[1]/div/nav/div/div/div[2]/div/div[3]/button'))
        )
        print("‚úì Bot√£o 'Submiss√£o de Laudos' encontrado! Clicando...")
        submissao_button.click()
       
        # Aguardar carregamento da nova tela
        time.sleep(3)
       
        # Clicar em "Upload de Laudos"
        print("Procurando bot√£o 'Upload de Laudos'...")
        upload_button = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[2]/div/div[2]'))
        )
        print("‚úì Bot√£o 'Upload de Laudos' encontrado! Clicando...")
        upload_button.click()
       
        print("‚úì Navega√ß√£o conclu√≠da com sucesso!")
        return True
       
    except TimeoutException:
        print("‚ö† Timeout: Bot√µes n√£o encontrados no tempo esperado.")
        return False
    except Exception as e:
        print(f"‚ö† Erro na navega√ß√£o: {e}")
        return False
 
def select_excel_file():
    """Abre dialog para selecionar arquivo Excel"""
    if not HAS_PANDAS:
        print("Erro: Pandas n√£o est√° instalado. Execute: pip install pandas")
        return None, None
   
    try:
        print("\n" + "="*50)
        print("SELE√á√ÉO DE ARQUIVO EXCEL")
        print("="*50)
       
        # Configurar Tkinter (ocultar janela principal)
        root = tk.Tk()
        root.withdraw()
       
        # Abrir dialog de sele√ß√£o de arquivo
        file_path = filedialog.askopenfilename(
            title="Selecione o arquivo Excel",
            filetypes=(("Arquivos Excel", "*.xlsx *.xls"), ("Todos os arquivos", "*.*"))
        )
       
        root.destroy()
       
        if not file_path:
            print("Nenhum arquivo selecionado.")
            return None, None
       
        print(f"‚úì Arquivo selecionado: {file_path}")
       
        # Ler o arquivo Excel
        print("Carregando planilha...")
        df = pd.read_excel(file_path)
        print(f"‚úì Planilha carregada com {len(df)} linhas")
       
        return file_path, df
       
    except Exception as e:
        print(f"Erro ao selecionar/carregar arquivo: {e}")
        return None, None
 
def filter_by_nucleo_and_ocorrencia(df):
    """Filtra dados por n√∫cleo e ocorr√™ncia predominante"""
    try:
        print("\n" + "="*50)
        print("FILTRO POR N√öCLEO")
        print("="*50)
       
        # Verificar se coluna 'Nucleo' existe
        if 'Nucleo' not in df.columns:
            print("‚ö† Erro: Coluna 'Nucleo' n√£o encontrada na planilha.")
            print("Colunas dispon√≠veis:", list(df.columns))
            return None, 0, None, None
       
        # Mostrar n√∫cleos √∫nicos dispon√≠veis
        nucleos_unicos = df['Nucleo'].unique()
        print("N√∫cleos dispon√≠veis na planilha:")
        for i, nucleo in enumerate(nucleos_unicos, 1):
            count = len(df[df['Nucleo'] == nucleo])
            print(f"  {i}. {nucleo} ({count} registros)")
       
        # Solicitar n√∫cleo
        nucleo_input = input("\nDigite o nome do n√∫cleo para filtrar: ").strip()
       
        if not nucleo_input:
            print("N√∫cleo n√£o informado.")
            return None, 0, None, None
       
        # Filtrar dados por n√∫cleo
        df_nucleo = df[df['Nucleo'].str.contains(nucleo_input, case=False, na=False)]
       
        if len(df_nucleo) == 0:
            print(f"‚ö† Nenhum registro encontrado para o n√∫cleo '{nucleo_input}'")
            return None, 0, None, None
       
        print(f"‚úì N√∫cleo filtrado: {len(df_nucleo)} registros encontrados para '{nucleo_input}'")
       
        # Verificar se coluna 'Ocorr√™ncia Predominante' existe
        if 'Ocorr√™ncia Predominante' not in df_nucleo.columns:
            print("‚ö† Erro: Coluna 'Ocorr√™ncia Predominante' n√£o encontrada na planilha.")
            print("Colunas dispon√≠veis:", list(df_nucleo.columns))
            return None, 0, nucleo_input, None
       
        print("\n" + "="*50)
        print("FILTRO POR OCORR√äNCIA PREDOMINANTE")
        print("="*50)
       
        # Mostrar ocorr√™ncias √∫nicas dispon√≠veis
        ocorrencias_unicas = df_nucleo['Ocorr√™ncia Predominante'].unique()
        print("Ocorr√™ncias predominantes dispon√≠veis:")
        for i, ocorrencia in enumerate(ocorrencias_unicas, 1):
            count = len(df_nucleo[df_nucleo['Ocorr√™ncia Predominante'] == ocorrencia])
            print(f"  {i}. {ocorrencia} ({count} registros)")
       
        # Solicitar ocorr√™ncia
        ocorrencia_input = input("\nDigite o nome da ocorr√™ncia predominante para filtrar: ").strip()
       
        if not ocorrencia_input:
            print("Ocorr√™ncia n√£o informada.")
            return None, 0, nucleo_input, None
       
        # Filtrar dados por ocorr√™ncia
        df_filtrado = df_nucleo[df_nucleo['Ocorr√™ncia Predominante'].str.contains(ocorrencia_input, case=False, na=False)]
       
        if len(df_filtrado) == 0:
            print(f"‚ö† Nenhum registro encontrado para a ocorr√™ncia '{ocorrencia_input}'")
            return None, 0, nucleo_input, None
       
        print(f"‚úì Filtros aplicados: {len(df_filtrado)} registros encontrados")
       
        # Mostrar resumo dos dados filtrados
        print("\nResumo dos dados que ser√£o lan√ßados:")
        print(f"  - Total de registros: {len(df_filtrado)}")
        print(f"  - N√∫cleo: {nucleo_input}")
        print(f"  - Ocorr√™ncia Predominante: {ocorrencia_input}")
       
        if 'UP' in df_filtrado.columns:
            print(f"  - UPs encontradas: {df_filtrado['UP'].nunique()}")
       
        return df_filtrado, len(df_filtrado), nucleo_input, ocorrencia_input
       
    except Exception as e:
        print(f"Erro ao filtrar dados: {e}")
        return None, 0, None, None
 
def get_diagnostico_text(ocorrencia):
    """Retorna o texto de diagn√≥stico fixo para todas as ocorr√™ncias"""
    return (
        "Foi objeto deste Laudo as √°reas afetadas por inc√™ndios florestais e vendaval (D√©ficit H√≠drico), conforme as caracter√≠sticas de danos a seguir:\n\n"
        "Seca e mortalidade dos plantios devido ao fogo ou d√©ficit h√≠drico em diferentes n√≠veis de severidade;\n\n"
        "Inclina√ß√£o, tombamento e quebra de √°rvores devido a ocorr√™ncia de vendaval.\n\n"
        "Para as ocorr√™ncias foram observados danos em reboleiras de diferentes tamanhos de √°rea (ha) e intensidade dentro dos talh√µes."
    )
 
def get_licoes_text(ocorrencia):
    """Retorna o texto fixo de li√ß√µes aprendidas para todas as ocorr√™ncias"""
    return (
        "As visitas de campo juntamente com imagens de drones s√£o fundamentais para a tomada de decis√£o. "
        "As ocorr√™ncias de sinistros s√£o din√¢micas e, desta forma, √© fundamental aguardar o tempo recomendado para a verifica√ß√£o da recupera√ß√£o das plantas bem como manter as informa√ß√µes atualizadas, especialmente nas ocorr√™ncias de D√©ficit H√≠drico e Inc√™ndios Florestais. "
        "A efetiva√ß√£o da baixa e tratativas devem ocorrer imediatamente ap√≥s a libera√ß√£o do laudo, evitando-se retrabalho e dificuldades na rastreabilidade de todo o processo, assim como o comprometimento da produtividade no site."
    )
 
def fill_header_fields(driver, wait, nucleo, ocorrencia):
    """Preenche os campos de cabe√ßalho do formul√°rio"""
    try:
        print("\n" + "="*60)
        print("PREENCHIMENTO DOS CAMPOS DE CABE√áALHO")
        print("="*60)
       
        # Campo Objetivo
        print("Preenchendo campo 'Objetivo'...")
        objetivo_text = f"O presente relat√≥rio foi elaborado por solicita√ß√£o do GEOCAT com o objetivo de avaliar os efeitos dos sinistros nos plantios do N√∫cleo {nucleo} e determinar as recomenda√ß√µes para as √°reas avaliadas em campo pela √°rea de Mensura√ß√£o."
       
        objetivo_field = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[3]/div/div/div/div[2]/div/div/div/div/div[2]/div/div/form/div[1]/div[3]/div/div[1]/div/div/textarea'))
        )
        objetivo_field.clear()
        objetivo_field.send_keys(objetivo_text)
        print("‚úì Campo 'Objetivo' preenchido com sucesso!")
       
        # Aguardar um pouco
        time.sleep(2)
       
        # Campo Diagn√≥stico
        print("Preenchendo campo 'Diagn√≥stico'...")
        diagnostico_text = get_diagnostico_text(ocorrencia)
       
        diagnostico_field = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[3]/div/div/div/div[2]/div/div/div/div/div[2]/div/div/form/div[1]/div[3]/div/div[2]/div/div/textarea'))
        )
        diagnostico_field.clear()
        diagnostico_field.send_keys(diagnostico_text)
        print("‚úì Campo 'Diagn√≥stico' preenchido com sucesso!")
       
        # Aguardar um pouco
        time.sleep(2)
       
        # Campo Li√ß√µes Aprendidas
        print("Preenchendo campo 'Li√ß√µes Aprendidas'...")
        licoes_text = get_licoes_text(ocorrencia)
       
        licoes_field = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[3]/div/div/div/div[2]/div/div/div/div/div[2]/div/div/form/div[1]/div[3]/div/div[3]/div/div/textarea'))
        )
        licoes_field.clear()
        licoes_field.send_keys(licoes_text)
        print("‚úì Campo 'Li√ß√µes Aprendidas' preenchido com sucesso!")
       
        print("\n‚úì Todos os campos de cabe√ßalho foram preenchidos com sucesso!")
        time.sleep(1)
        pyautogui.press('tab')
        time.sleep(1)
        pyautogui.press('tab')
        return True
       
    except TimeoutException:
        print("‚ö† Timeout: Campos n√£o encontrados no tempo esperado.")
        return False
    except Exception as e:
        print(f"‚ö† Erro ao preencher campos: {e}")
        return False
 
def get_tipo_dano_steps(ocorrencia):
    """Retorna o n√∫mero de setas para baixo necess√°rias baseado na ocorr√™ncia"""
    if "DEFICIT HIDRICO" in ocorrencia.upper():
        return 2
    elif "GEADA" in ocorrencia.upper():
        return 6
    elif "INCENDIO" in ocorrencia.upper():
        return 7
    elif "VENDAVAL" in ocorrencia.upper():
        return 9
    else:
        return 1  # Default
 
def get_severidade_steps(severidade):
    """Retorna o n√∫mero de setas para baixo necess√°rias baseado na severidade"""
    if "BAIXO" in severidade.upper():
        return 0
    elif "MEDIO" in severidade.upper():
        return 1
    elif "ALTO" in severidade.upper():
        return 2
    else:
        return 1  # Default
 
def get_recomendacao_steps(recomendacao, idade, incidencia):
    """Retorna o n√∫mero de setas para baixo necess√°rias baseado na recomenda√ß√£o"""
    if "Avaliar (manter/erradicar)" in recomendacao:
        return 6
    elif "Erradicar" in recomendacao:
        if idade >= 3 and incidencia < 100:
            return 2
        elif idade >= 3 and incidencia == 100:
            return 1
        elif idade < 3 and incidencia == 100:
            return 4
        elif idade < 3 and incidencia < 100:
            return 5
        else:
            return 2  # Default
    elif "Manter ciclo/rota√ß√£o" in recomendacao:
        return 3
    else:  # (vazio) ou outros
        return 6
 
def process_ups_data(driver, wait, df_filtrado):
    """Lan√ßa todas as UPs do DataFrame filtrado usando navega√ß√£o por teclado"""
    try:
        if not HAS_PYAUTOGUI:
            print("Erro: PyAutoGUI n√£o est√° instalado. Execute: pip install pyautogui")
            return False
       
        print("\n" + "="*60)
        print("LAN√áAMENTO DAS UPs")
        print("="*60)
       
        # Obter lista de UPs √∫nicas com seus dados
        total_ups = len(df_filtrado)
       
        print(f"Iniciando lan√ßamento de {total_ups} UPs...")
        print("IMPORTANTE: N√£o mova o mouse durante o processo!")
       
        # Aguardar confirma√ß√£o
        input("Pressione Enter quando estiver pronto para iniciar o lan√ßamento autom√°tico...")
       
        # Aguardar um pouco e rolar para baixo
        time.sleep(2)
        driver.execute_script("window.scrollBy(0, 500);")
        time.sleep(2)
       
        # Contador de UPs processadas
        successful_ups = 0
        failed_ups = 0
       
        # Iterar sobre todas as linhas do DataFrame
        for index, row in df_filtrado.iterrows():
            up = row['UP']
            ocorrencia = row['Ocorr√™ncia Predominante']
            severidade = row['Severidade Predominante']
            recomendacao = row['Recomendacao']
            idade = row['Idade']
            incidencia = row['Incidencia']
           
            if not up:
                print(f"UP {index + 1}: Valor vazio, pulando...")
                failed_ups += 1
                continue
           
            try:
                print(f"Processando UP {index + 1}/{total_ups}: {up}")
                print(f"  - Ocorr√™ncia: {ocorrencia}")
                print(f"  - Severidade: {severidade}")
                print(f"  - Recomenda√ß√£o: {recomendacao}")
                print(f"  - Idade: {idade}, Incid√™ncia: {incidencia}%")
               
                # 1. Clicar no campo UP e digitar valor aparecer aqui
                #pyautogui.click(425, 792) # monitor grande
                pyautogui.click(227, 715) # monitor pequeno
                time.sleep(1)
                pyautogui.typewrite(str(up))
                time.sleep(1)
                pyautogui.press('Enter')
                time.sleep(1)
               
                               
                # 3. Apertar Tab novamente para ir para sele√ß√£o do tipo de dano
                pyautogui.press('tab')
                time.sleep(1)
               
                # 4. Selecionar tipo de dano baseado na ocorr√™ncia
                tipo_dano_steps = get_tipo_dano_steps(ocorrencia)
                print(f"  - Selecionando tipo de dano: {tipo_dano_steps} setas para baixo")
               
                for _ in range(tipo_dano_steps):
                    pyautogui.press('down')
                    time.sleep(0.2)
               
                pyautogui.press('space')
                time.sleep(1)
               
                # 5. Selecionar Ocorr√™ncia na UP
                print(f"  - Selecionando ocorr√™ncia na UP")
                pyautogui.press('tab')
                time.sleep(1)
                pyautogui.press('down')
                time.sleep(1)
                pyautogui.press('space')
                time.sleep(1)
               
                # 6. Selecionar Severidade
                print(f"  - Selecionando severidade: {severidade} e Incidencia: {incidencia}%")
                pyautogui.press('tab')
                time.sleep(1)
                pyautogui.press('tab')
                time.sleep(1)
                
                # Ajusta incid√™ncia para 100% se recomenda√ß√£o for "Manter ciclo"
                if "Manter ciclo" in recomendacao:
                    pyautogui.typewrite("100.00")
                else:
                    pyautogui.typewrite(f"{incidencia * 100:.2f}")
                
                time.sleep(1)
                pyautogui.press('tab')
                time.sleep(1)
                pyautogui.press('down')
                time.sleep(1)
               
                severidade_steps = get_severidade_steps(severidade)
                for _ in range(severidade_steps):
                    pyautogui.press('down')
                    time.sleep(0.2)
               
                pyautogui.press('space')
                time.sleep(1)
               
                # 7. Selecionar Recomenda√ß√£o
                print(f"  - Selecionando recomenda√ß√£o: {recomendacao}")
                pyautogui.press('tab')
                time.sleep(1)
               
                recomendacao_steps = get_recomendacao_steps(recomendacao, idade, incidencia)
                print(f"    (Idade: {idade}, Incid√™ncia: {incidencia}% -> {recomendacao_steps} setas)")
               
                for _ in range(recomendacao_steps):
                    pyautogui.press('down')
                    time.sleep(0.2)
               
                pyautogui.press('space')
                time.sleep(1)
               
                # 8. Clicar no bot√£o para adicionar UP
                try:
                    add_button = wait.until(
                        EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[3]/div/div/div/div[2]/div/div/div/div/div[2]/div/div/form/div[2]/div/div[3]/button'))
                    )
                    add_button.click()
                    time.sleep(2)
                except:
                    print(f"  ‚ö† Erro ao clicar no bot√£o de adicionar para UP {up}")
               
                # 9. Rolar p√°gina
                driver.execute_script("window.scrollBy(0, 500);")
                time.sleep(2)
               
                successful_ups += 1
                print(f"‚úì UP {up} processada com sucesso!")
               
            except Exception as e:
                print(f"‚ö† Erro ao processar UP {up}: {e}")
                failed_ups += 1
       
        # Relat√≥rio do lan√ßamento
        print(f"\n" + "="*50)
        print("RELAT√ìRIO DO LAN√áAMENTO DE UPs")
        print("="*50)
        print(f"Total de UPs: {total_ups}")
        print(f"UPs lan√ßadas com sucesso: {successful_ups}")
        print(f"UPs que falharam: {failed_ups}")
        print(f"Taxa de sucesso: {(successful_ups/total_ups)*100:.1f}%")
       
        return True
       
    except Exception as e:
        print(f"Erro durante o lan√ßamento das UPs: {e}")
        return False
 
def fill_final_considerations(driver, wait, df_filtrado):
    """Preenche o campo de considera√ß√µes finais com texto fixo"""
    try:
        print("\n" + "="*60)
        print("PREENCHIMENTO DAS CONSIDERA√á√ïES FINAIS")
        print("="*60)
        
        # Texto fixo para as considera√ß√µes finais
        consideracoes_text = (
            "Face ao exposto, com a avalia√ß√£o de ha, recomenda-se:\n\n"
            "Limpeza T√©cnica\n\n"
            "XX,xx ha de √°rea total das UPs;\n\n"
            "XX,xx ha de √°rea parcial das UPs.\n\n"
            "Antecipa√ß√£o de Colheita\n\n"
            "XX,xx ha de √°rea total das UPs;\n\n"
            "XX,xx ha de √°rea parcial das UPs.\n\n"
            "Manuten√ß√£o do Ciclo e Rota√ß√£o\n\n"
            "XX,xx ha de √°rea parcial da UP.\n\n"
            "O valor total imobilizado a ser apurado como preju√≠zo ser√° de R$ X (XX reais e XXXX centavos), "
            "informado pela √°rea Cont√°bil. Vale ressaltar que o montante descrito pode sofrer altera√ß√µes "
            "entre o per√≠odo de emiss√£o, assinaturas e devida baixa dos ativos; no momento da baixa, a "
            "Gest√£o Patrimonial far√° a atualiza√ß√£o e manter√° comprova√ß√£o anexa ao laudo. A destina√ß√£o da "
            "madeira e eventuais dificuldades operacionais n√£o foram objeto deste laudo.\n\n"
            "As recomenda√ß√µes s√£o por UP, considerando a ocorr√™ncia de maior abrang√™ncia; pode, contudo, "
            "existir mais de um tipo de sinistro na mesma UP, sendo necess√°ria uma avalia√ß√£o detalhada do "
            "microplanejamento quanto ao aproveitamento da madeira.\n\n"
            "O laudo foi elaborado com base em croquis e fotos fornecidos pela equipe de mensura√ß√£o florestal. "
            "A aus√™ncia de imagens a√©reas de alta resolu√ß√£o e a falta de visitas de campo por parte dos "
            "extensionistas prejudicam a avalia√ß√£o detalhada das UPs. Assim, se a equipe de Silvicultura, "
            "durante a execu√ß√£o das a√ß√µes recomendadas, constatar diverg√™ncias em campo, recomenda-se delimitar "
            "a √°rea divergente a ser aproveitada e solicitar uma an√°lise adicional √† equipe de extens√£o tecnol√≥gica."
        )
        
        print("Preenchendo campo 'Considera√ß√µes Finais'...")
       
        # Localizar e preencher o campo
        consideracoes_field = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[3]/div/div/div/div[2]/div/div/div/div/div[2]/div/div/form/div[1]/div[3]/div/div[4]/div/div/textarea'))
        )
        consideracoes_field.clear()
        consideracoes_field.send_keys(consideracoes_text)
       
        print("‚úì Campo 'Considera√ß√µes Finais' preenchido com sucesso!")
        return True
       
    except TimeoutException:
        print("‚ö† Timeout: Campo de considera√ß√µes finais n√£o encontrado.")
        return False
    except Exception as e:
        print(f"‚ö† Erro ao preencher considera√ß√µes finais: {e}")
        prosseguir = input("Deseja prosseguir mesmo assim? (s/n): ").strip().lower()
        if prosseguir not in ['s', 'sim', 'y', 'yes']:
            print("Processo interrompido pelo usu√°rio devido ao erro ao preencher considera√ß√µes finais.")
            return False
        return True
 
def display_data_table(df_filtrado):
    """Exibe tabela formatada com os dados processados"""
    try:
        print("\n" + "="*120)
        print("TABELA DE DADOS PROCESSADOS")
        print("="*120)

        # Colunas que queremos exibir
        required_columns = [
            'UP', 'Nucleo', 'Idade', 'Ocorr√™ncia Predominante',
            'Severidade Predominante', 'Area UP', 'Area Liquida',
            'Incidencia', 'Recomendacao'
        ]

        # Verifica se todas as colunas existem
        missing_columns = [c for c in required_columns if c not in df_filtrado.columns]
        if missing_columns:
            print(f"‚ö† Aviso: Colunas ausentes: {missing_columns}")
            print("Exibindo somente as colunas dispon√≠veis‚Ä¶")
        available_columns = [c for c in required_columns if c in df_filtrado.columns]

        # Copia apenas as colunas dispon√≠veis
        display_df = df_filtrado[available_columns].copy()

        # Formata valores num√©ricos
        for col in ['Area UP', 'Area Liquida', 'Incidencia']:
            if col in display_df.columns:
                display_df[col] = display_df[col].round(2)

        # Cabe√ßalho da tabela
        header = ""
        col_width = {
            'UP': 8, 'Nucleo': 15, 'Idade': 8, 'Ocorr√™ncia Predominante': 20,
            'Severidade Predominante': 15, 'Area UP': 10, 'Area Liquida': 10,
            'Incidencia': 10, 'Recomendacao': 25
        }
        for col in available_columns:
            header += f"{col:<{col_width[col]}}|"
        print(header)
        print("-" * len(header))

        # Linhas da tabela
        for _, row in display_df.iterrows():
            line = ""
            for col in available_columns:
                val = str(row[col])[:col_width[col]-2] + ".." \
                      if len(str(row[col])) > col_width[col] else str(row[col])
                line += f"{val:<{col_width[col]}}|"
            print(line)

        # Linha separadora
        print("-" * len(header))

        # Resumo estat√≠stico
        print("\nRESUMO ESTAT√çSTICO:")
        print(f"‚Ä¢ Total de UPs: {len(display_df)}")
        if 'Area UP' in display_df.columns:
            print(f"‚Ä¢ √Årea total UP: {display_df['Area UP'].sum():.2f} ha")
        if 'Area Liquida' in display_df.columns:
            print(f"‚Ä¢ √Årea l√≠quida total: {display_df['Area Liquida'].sum():.2f} ha")
        if 'Recomendacao' in display_df.columns:
            print(f"‚Ä¢ Tipos de recomenda√ß√£o: {display_df['Recomendacao'].nunique()}")

        print("="*120)
        return True

    except Exception as e:
        print(f"Erro ao exibir tabela de dados: {e}")
        return False
 
# =========================================================================
# FUN√á√ÉO PRINCIPAL
# =========================================================================
 
def open_fenix_site():
    """Abre o site Fenix Florestal e executa todo o processo"""
   
    # Testar conectividade (n√£o bloquear se falhar)
    test_connectivity()
   
    # Configurar op√ß√µes do Chrome
    options = Options()
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1920,1080")
    options.add_argument("--disable-web-security")
    options.add_argument("--allow-running-insecure-content")
    options.add_argument("--ignore-certificate-errors")
    options.add_argument("--ignore-ssl-errors")
    options.add_argument("--disable-extensions")
    options.add_argument("--no-proxy-server")
   
    driver = None
   
    try:
        print("Inicializando o navegador Chrome...")
       
        # Tentar primeira abordagem: WebDriver Manager com cache offline
        try:
            print("Tentando usar WebDriver Manager...")
            service = Service(ChromeDriverManager().install())
            driver = webdriver.Chrome(service=service, options=options)
        except Exception as e1:
            print(f"WebDriver Manager falhou: {e1}")
           
            # Segunda abordagem: Chrome sem especificar caminho do driver
            try:
                print("Tentando usar Chrome sem driver espec√≠fico...")
                driver = webdriver.Chrome(options=options)
            except Exception as e2:
                print(f"Chrome padr√£o falhou: {e2}")
               
                # Terceira abordagem: procurar ChromeDriver no PATH
                print("Tentando encontrar ChromeDriver no sistema...")
                driver = webdriver.Chrome(options=options)
       
        if driver is None:
            raise Exception("N√£o foi poss√≠vel inicializar o Chrome")
       
        # Definir timeout para carregamento de p√°gina
        driver.set_page_load_timeout(30)
        wait = WebDriverWait(driver, 10)
       
        print(f"Abrindo a p√°gina: {FENIX_URL}")
        driver.get(FENIX_URL)
       
        print("P√°gina aberta com sucesso!")
        print("Aguardando carregamento da p√°gina...")
        time.sleep(5)
       
        # Tentar clicar no bot√£o de login
        try:
            print("Procurando pelo bot√£o de login...")
            time.sleep(1)
            # Aguardar o bot√£o aparecer e ser clic√°vel
            login_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="__next"]/div[1]/div[2]/button'))
            )
            time.sleep(5)
            print("Bot√£o de login encontrado! Clicando...")
            login_button.click()
            
            # Aguardar campo de email aparecer
            print("Aguardando campo de email...")
            email_field = wait.until(
                EC.presence_of_element_located((By.XPATH, '//*[@id="i0116"]'))
            )
            email_field.send_keys("joaoco@suzano.com.br")
            time.sleep(5)
            # Clicar no bot√£o Avan√ßar ap√≥s email
            print("Clicando em Avan√ßar...")
            next_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="idSIButton9"]'))
            )
            time.sleep(5)
            next_button.click()
            time.sleep(1)
            
            # Aguardar campo de senha aparecer
            print("Aguardando campo de senha...")
            password_field = wait.until(
                EC.presence_of_element_located((By.XPATH, '//*[@id="i0118"]'))
            )
            time.sleep(1)
            password_field.send_keys("MFTUbilo192837")
            time.sleep(1)
            # Clicar no bot√£o Entrar ap√≥s senha
            print("Clicando em Entrar...")
            signin_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="idSIButton9"]'))
            )
            signin_button.click()
           
            print("‚úì Login inicial realizado com sucesso!")
            print("\n" + "="*60)
            print("AGUARDANDO AUTENTICA√á√ÉO DE DOIS FATORES")
            print("="*60)
            print("Por favor, complete a autentica√ß√£o de dois fatores no navegador.")
            print("Ap√≥s fazer login, pressione Enter aqui para continuar...")
            print("="*60)
           
            # Aguardar o usu√°rio completar a autentica√ß√£o
            input("Pressione Enter ap√≥s completar a autentica√ß√£o...")
           
            print("Continuando com o script...")
           
            while True:  # Loop principal para permitir m√∫ltiplos lan√ßamentos
                # Navegar para se√ß√£o de upload
                if navigate_to_upload_section(driver, wait):
                   
                    # Aguardar um pouco para a p√°gina carregar
                    time.sleep(3)
                   
                    # Selecionar arquivo Excel
                    file_path, df = select_excel_file()
                   
                    if df is not None:
                        # Filtrar por n√∫cleo e ocorr√™ncia
                        df_filtrado, total_registros, nucleo_selecionado, ocorrencia_selecionada = filter_by_nucleo_and_ocorrencia(df)
                       
                        if df_filtrado is not None and total_registros > 0:
                            print(f"\n‚úì Processo preparado!")
                            print(f"Arquivo: {file_path}")
                            print(f"N√∫cleo: {nucleo_selecionado}")
                            print(f"Ocorr√™ncia: {ocorrencia_selecionada}")
                            print(f"Registros a serem lan√ßados: {total_registros}")
                           
                            # Aguardar confirma√ß√£o para prosseguir
                            confirmar = input(f"\nDeseja prosseguir com o lan√ßamento de {total_registros} registros? (s/n): ").strip().lower()
                           
                            if confirmar in ['s', 'sim', 'y', 'yes']:
                                print("\n" + "="*60)
                                print("IMPORTANTE: PREENCHIMENTO MANUAL DO CABE√áALHO")
                                print("="*60)
                                print("Antes de iniciar o lan√ßamento autom√°tico das UPs,")
                                print("voc√™ precisa preencher manualmente o cabe√ßalho do formul√°rio.")
                                print("\nPor favor:")
                                print("1. Preencha todos os campos necess√°rios do cabe√ßalho")
                                print("2. N√ÉO salve ainda")
                                print("3. Deixe o formul√°rio aberto")
                               
                                input("\nPressione Enter quando terminar o preenchimento manual...")
                               
                                # Preencher campos automaticamente
                                if fill_header_fields(driver, wait, nucleo_selecionado, ocorrencia_selecionada):
                                    print("\n‚úì Cabe√ßalho preenchido automaticamente!")
                                   
                                    # Perguntar se deseja lan√ßar as UPs
                                    lancar_ups = input("\nDeseja iniciar o lan√ßamento das UPs? (s/n): ").strip().lower()
                                   
                                    if lancar_ups in ['s', 'sim', 'y', 'yes']:
                                        if process_ups_data(driver, wait, df_filtrado):
                                            print("\n‚úì UPs lan√ßadas com sucesso!")
                                           
                                            # Preencher considera√ß√µes finais
                                            if fill_final_considerations(driver, wait, df_filtrado):
                                                print("\n" + "="*60)
                                                print("PROCESSO CONCLU√çDO COM SUCESSO!")
                                                print("="*60)
                                                print("‚úì Cabe√ßalho preenchido")
                                                print("‚úì UPs lan√ßadas")
                                                print("‚úì Considera√ß√µes finais preenchidas")
                                                print("\nüîç IMPORTANTE: REVIS√ÉO NECESS√ÅRIA")
                                                print("="*60)
                                                print("Por favor, fa√ßa uma revis√£o completa de todos os laudos lan√ßados!")
                                                print("Verifique:")
                                                print("‚Ä¢ Se todas as UPs foram lan√ßadas corretamente")
                                                print("‚Ä¢ Se os dados est√£o consistentes")
                                                print("‚Ä¢ Se as recomenda√ß√µes est√£o adequadas")
                                                print("‚Ä¢ Se n√£o h√° erros de digita√ß√£o")
                                                
                                                # For√ßar exibi√ß√£o da tabela de dados
                                                print("\n" + "="*60)
                                                print("DADOS PROCESSADOS PARA REVIS√ÉO")
                                                print("="*60)
                                                display_data_table(df_filtrado)
                                                
                                                print("\nAp√≥s a revis√£o, voc√™ pode salvar o laudo.")
                                        else:
                                            print("‚ö† Erro no lan√ßamento das UPs.")
                                    else:
                                        print("Lan√ßamento das UPs cancelado pelo usu√°rio.")
                                else:
                                    print("‚ö† Erro no preenchimento autom√°tico do cabe√ßalho.")
                            else:
                                print("Processo cancelado pelo usu√°rio.")
                        else:
                            print("Processo interrompido - dados inv√°lidos.")
                    else:
                        print("Processo interrompido - arquivo n√£o selecionado.")
                else:
                    print("Falha na navega√ß√£o para se√ß√£o de upload.")
                
                # Perguntar se deseja fazer outro lan√ßamento
                continuar = input("\nDeseja fazer outro lan√ßamento? (s/n): ").strip().lower()
                if continuar not in ['s', 'sim', 'y', 'yes']:
                    break
           
        except TimeoutException:
            print("‚ö† Bot√£o de login n√£o encontrado no tempo esperado.")
            print("Verifique se a p√°gina carregou corretamente.")
            # Perguntar se deseja tentar seguir para o pr√≥ximo passo
            seguir = input("Deseja tentar seguir para o pr√≥ximo passo mesmo assim? (s/n): ").strip().lower()
            if seguir in ['s', 'sim', 'y', 'yes']:
                if navigate_to_upload_section(driver, wait):
                    time.sleep(3)
                    file_path, df = select_excel_file()
                    if df is not None:
                        df_filtrado, total_registros, nucleo_selecionado, ocorrencia_selecionada = filter_by_nucleo_and_ocorrencia(df)
                        if df_filtrado is not None and total_registros > 0:
                            print(f"\n‚úì Processo preparado!")
                            print(f"Arquivo: {file_path}")
                            print(f"N√∫cleo: {nucleo_selecionado}")
                            print(f"Ocorr√™ncia: {ocorrencia_selecionada}")
                            print(f"Registros a serem lan√ßados: {total_registros}")
                            confirmar = input(f"\nDeseja prosseguir com o lan√ßamento de {total_registros} registros? (s/n): ").strip().lower()
                            if confirmar in ['s', 'sim', 'y', 'yes']:
                                print("\n" + "="*60)
                                print("IMPORTANTE: PREENCHIMENTO MANUAL DO CABE√áALHO")
                                print("="*60)
                                print("Antes de iniciar o lan√ßamento autom√°tico das UPs,")
                                print("voc√™ precisa preencher manualmente o cabe√ßalho do formul√°rio.")
                                print("\nPor favor:")
                                print("1. Preencha todos os campos necess√°rios do cabe√ßalho")
                                print("2. N√ÉO salve ainda")
                                print("3. Deixe o formul√°rio aberto")
                                input("\nPressione Enter quando terminar o preenchimento manual...")
                                if fill_header_fields(driver, wait, nucleo_selecionado, ocorrencia_selecionada):
                                    print("\n‚úì Cabe√ßalho preenchido automaticamente!")
                                    lancar_ups = input("\nDeseja iniciar o lan√ßamento das UPs? (s/n): ").strip().lower()
                                    if lancar_ups in ['s', 'sim', 'y', 'yes']:
                                        if process_ups_data(driver, wait, df_filtrado):
                                            print("\n‚úì UPs lan√ßadas com sucesso!")
                                            if fill_final_considerations(driver, wait, df_filtrado):
                                                print("\n" + "="*60)
                                                print("PROCESSO CONCLU√çDO COM SUCESSO!")
                                                print("="*60)
                                                print("‚úì Cabe√ßalho preenchido")
                                                print("‚úì UPs lan√ßadas")
                                                print("‚úì Considera√ß√µes finais preenchidas")
                                                print("\nüîç IMPORTANTE: REVIS√ÉO NECESS√ÅRIA")
                                                print("="*60)
                                                print("Por favor, fa√ßa uma revis√£o completa de todos os laudos lan√ßados!")
                                                print("Verifique:")
                                                print("‚Ä¢ Se todas as UPs foram lan√ßadas corretamente")
                                                print("‚Ä¢ Se os dados est√£o consistentes")
                                                print("‚Ä¢ Se as recomenda√ß√µes est√£o adequadas")
                                                print("‚Ä¢ Se n√£o h√° erros de digita√ß√£o")
                                                print("\n" + "="*60)
                                                print("DADOS PROCESSADOS PARA REVIS√ÉO")
                                                print("="*60)
                                                display_data_table(df_filtrado)
                                                print("\nAp√≥s a revis√£o, voc√™ pode salvar o laudo.")
                                        else:
                                            print("‚ö† Erro no lan√ßamento das UPs.")
                                    else:
                                        print("Lan√ßamento das UPs cancelado pelo usu√°rio.")
                                else:
                                    print("‚ö† Erro no preenchimento autom√°tico do cabe√ßalho.")
                            else:
                                print("Processo cancelado pelo usu√°rio.")
                        else:
                            print("Processo interrompido - dados inv√°lidos.")
                    else:
                        print("Processo interrompido - arquivo n√£o selecionado.")
                else:
                    print("Falha na navega√ß√£o para se√ß√£o de upload.")
            else:
                print("\nNavegador permanece aberto...")
                input("Pressione Enter para fechar o navegador...")
   
    except Exception as e:
        print(f"Erro ao abrir o site: {e}")
        print("\nSOLU√á√ïES POSS√çVEIS:")
        print("1. Baixe o ChromeDriver manualmente:")
        print("   - V√° em: https://chromedriver.chromium.org/")
        print("   - Baixe a vers√£o compat√≠vel com seu Chrome")
        print("   - Coloque o chromedriver.exe na mesma pasta deste script")
        print("2. Ou adicione o ChromeDriver ao PATH do Windows")
        print("3. Verifique se o Chrome est√° instalado")
       
    finally:
        if driver:
            fechar = input("\nDeseja fechar o navegador? (s/n): ").strip().lower()
            if fechar in ['s', 'sim', 'y', 'yes']:
                driver.quit()
                print("Navegador fechado.")
            else:
                print("Navegador permanecer√° aberto para uso manual.")

# =========================================================================
# EXECU√á√ÉO
# =========================================================================

if __name__ == "__main__":
    open_fenix_site()