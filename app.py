import streamlit as st
import pandas as pd
import time
import traceback
from datetime import datetime
from cria_pdf import criar_pdf_streamlit
from lancamento_fenix import executar_lancamento_fenix, get_recomendacao, atualizar_status_planilha, fechar_navegador_manual
from lancamento_fenix_hard import executar_lancamento_fenix_hard, obter_propriedades_por_unf

# Mantendo apenas as fun√ß√µes auxiliares de texto que s√£o usadas pela interface

def get_objetivo_text(nucleo):
    """Retorna o texto do objetivo"""
    return f"O presente relat√≥rio foi elaborado por solicita√ß√£o do GEOCAT com o objetivo de avaliar os efeitos dos sinistros nos plantios do N√∫cleo {nucleo} e determinar as recomenda√ß√µes para as √°reas avaliadas em campo pela √°rea de Mensura√ß√£o."

def get_diagnostico_text():
    """Retorna o texto de diagn√≥stico fixo"""
    return (
        "Foi objeto deste Laudo as √°reas afetadas por inc√™ndios florestais e vendaval (D√©ficit H√≠drico), conforme as caracter√≠sticas de danos a seguir:\n\n"
        "Seca e mortalidade dos plantios devido ao fogo ou d√©ficit h√≠drico em diferentes n√≠veis de severidade;\n\n"
        "Inclina√ß√£o, tombamento e quebra de √°rvores devido a ocorr√™ncia de vendaval.\n\n"
        "Para as ocorr√™ncias foram observados danos em reboleiras de diferentes tamanhos de √°rea (ha) e intensidade dentro dos talh√µes."
    )

def get_licoes_text():
    """Retorna o texto fixo de li√ß√µes aprendidas"""
    return (
        "As visitas de campo juntamente com imagens de drones s√£o fundamentais para a tomada de decis√£o. "
        "As ocorr√™ncias de sinistros s√£o din√¢micas e, desta forma, √© fundamental aguardar o tempo recomendado para a verifica√ß√£o da recupera√ß√£o das plantas bem como manter as informa√ß√µes atualizadas, especialmente nas ocorr√™ncias de D√©ficit H√≠drico e Inc√™ndios Florestais. "
        "A efetiva√ß√£o da baixa e tratativas devem ocorrer imediatamente ap√≥s a libera√ß√£o do laudo, evitando-se retrabalho e dificuldades na rastreabilidade de todo o processo, assim como o comprometimento da produtividade no site."
    )

def get_consideracoes_text():
    """Retorna o texto das considera√ß√µes finais"""
    return (
        "Face ao exposto, com a avalia√ß√£o de ha, recomenda-se:\n\n"
        "O valor total imobilizado a ser apurado como preju√≠zo ser√° de R$ X (XX reais e XXXX centavos), "
        "informado pela √°rea Cont√°bil. Vale ressaltar que o montante descrito pode sofrer altera√ß√µes "
        "entre o per√≠odo de emiss√£o, assinaturas e devida baixa dos ativos; no momento da baixa, a "
        "Gest√£o Patrimonial far√° a atualiza√ß√£o e manter√° comprova√ß√£o anexa ao laudo. A destina√ß√£o da "
        "madeira e eventuais dificuldades operacionais n√£o foram objeto deste laudo.\n\n"
        "As recomenda√ß√µes s√£o por UP, considerando a ocorr√™ncia de maior abrang√™ncia; pode, contudo, "
        "existir mais de um tipo de sinistro na mesma UP, sendo necess√°ria uma avalia√ß√£o detalhada do "
        "microplanejamento quanto ao aproveitamento da madeira.\n\n"
        "O laudo foi elaborado com base em croquis e fotos fornecidos pela equipe de mensura√ß√£o florestal. "
        "A aus√™ncia de imagens a√©reas de alta resolu√ß√£o e a falta de visitas de campo por parte dos "
        "extensionistas prejudicam a avalia√ß√£o detalhada das UPs. Assim, se a equipe de Silvicultura, "
        "durante a execu√ß√£o das a√ß√µes recomendadas, constatar diverg√™ncias em campo, recomenda-se delimitar "
        "a √°rea divergente a ser aproveitada e solicitar uma an√°lise adicional √† equipe de extens√£o tecnol√≥gica."
    )

def lancamento_fenix():
    st.header("Lan√ßamento de Informa√ß√µes no F√™nix")
    
    # Verificar se h√° op√ß√£o de continuar lan√ßamento
    if hasattr(st.session_state, 'mostrar_continuar_lancamento') and st.session_state.mostrar_continuar_lancamento:
        st.success("üéâ N√∫cleo anterior processado com sucesso!")
        st.info("üîÑ Navegador mantido aberto para continuar com outros n√∫cleos")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚ûï Continuar com Outro N√∫cleo", key="continuar_lancamento", type="primary", use_container_width=True):
                st.session_state.mostrar_continuar_lancamento = False
                st.rerun()
        
        with col2:
            if st.button("üîö Finalizar e Fechar Navegador", key="finalizar_lancamento", use_container_width=True):
                if fechar_navegador_manual():
                    st.success("‚úÖ Navegador fechado com sucesso!")
                    time.sleep(2)
                    st.rerun()
        
        st.markdown("---")
    
    # Upload do arquivo Excel
    uploaded_file = st.file_uploader("Escolha um arquivo Excel", type=['xlsx', 'xls'], key="lancamento_excel_uploader")
    
    if uploaded_file is not None:
        try:
            # L√™ o arquivo Excel
            df = pd.read_excel(uploaded_file)
            
            # Verifica se as colunas necess√°rias existem
            required_columns = [
                'UP', 'Nucleo', 'Idade', 'Ocorr√™ncia Predominante',
                'Severidade Predominante', 'Incidencia', 'Laudo Existente',
                'Recomendacao'
            ]
            
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                st.error(f"Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                st.write("Colunas dispon√≠veis no arquivo:", list(df.columns))
                return
            
            # Filtra apenas registros sem laudo
            df_sem_laudo = df[df['Laudo Existente'].str.upper() == 'N√ÉO'].copy()
            
            if len(df_sem_laudo) == 0:
                st.warning("N√£o h√° registros sem laudo para processar.")
                return
            
            # Sele√ß√£o do tipo de organiza√ß√£o
            st.subheader("üìã Tipo de Organiza√ß√£o dos Laudos")
            tipo_organizacao = st.radio(
                "Como deseja organizar os laudos?",
                [
                    "üè¢ Por N√∫cleo (M√©todo Original)",
                    "üèóÔ∏è Por Propriedade (Coluna 4 da tabela)"
                ],
                help="N√∫cleo: Agrupa UPs por n√∫cleo. Propriedade: Agrupa UPs por propriedade (recomendado para laudos espec√≠ficos por propriedade)."
            )
            
            # Definir coluna de agrupamento baseada na sele√ß√£o
            if tipo_organizacao.startswith("üèóÔ∏è Por Propriedade"):
                # Usar coluna 4 (√≠ndice 3) como coluna de propriedade
                coluna_agrupamento = df.columns[3]  # Coluna 4 (√≠ndice base 0)
                st.info(f"‚úÖ Usando coluna de propriedade: **{coluna_agrupamento}**")
                
                # Agrupar por propriedade
                grupos_sem_laudo = df_sem_laudo.groupby(coluna_agrupamento).size().reset_index(name='quantidade_ups')
                grupos_sem_laudo = grupos_sem_laudo.rename(columns={coluna_agrupamento: 'Agrupamento'})
                tipo_label = "Propriedades"
                icone_agrupamento = "üèóÔ∏è"
            else:
                # Usar n√∫cleo (m√©todo original)
                coluna_agrupamento = 'Nucleo'
                grupos_sem_laudo = df_sem_laudo.groupby('Nucleo').size().reset_index(name='quantidade_ups')
                grupos_sem_laudo = grupos_sem_laudo.rename(columns={'Nucleo': 'Agrupamento'})
                tipo_label = "N√∫cleos"
                icone_agrupamento = "üè¢"
            
            # Manter compatibilidade com c√≥digo existente
            nucleos_sem_laudo = grupos_sem_laudo
            
            # Overview dos dados
            st.subheader("üìä Overview dos Dados")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Total de UPs sem laudo", len(df_sem_laudo))
            with col2:
                st.metric("N√∫cleos sem laudo", len(nucleos_sem_laudo))
            with col3:
                st.metric("Total de registros", len(df))
            
            # Tabela de grupos (n√∫cleos ou propriedades)
            st.subheader(f"{icone_agrupamento} {tipo_label} sem Laudo")
            st.dataframe(grupos_sem_laudo, use_container_width=True)
            
            # Op√ß√µes de lan√ßamento
            st.subheader("üöÄ Op√ß√µes de Lan√ßamento")
            
            # Bot√µes para cada grupo
            cols = st.columns(min(len(grupos_sem_laudo) + 1, 4))
            
            # Bot√£o para todos os grupos
            with cols[0]:
                if st.button(f"üéØ Todos os {tipo_label}", key="todos_grupos", use_container_width=True):
                    st.session_state.grupos_selecionados = grupos_sem_laudo['Agrupamento'].tolist()
                    st.session_state.opcao_selecionada = "todos"
                    st.session_state.tipo_organizacao = tipo_organizacao
                    st.session_state.coluna_agrupamento = coluna_agrupamento
            
            # Bot√µes individuais para cada grupo
            for idx, grupo in enumerate(grupos_sem_laudo['Agrupamento'].tolist()):
                col_idx = (idx + 1) % 4
                with cols[col_idx]:
                    if st.button(f"{icone_agrupamento} {grupo}", key=f"grupo_{idx}_{grupo}", use_container_width=True):
                        st.session_state.grupos_selecionados = [grupo]
                        st.session_state.opcao_selecionada = grupo
                        st.session_state.tipo_organizacao = tipo_organizacao
                        st.session_state.coluna_agrupamento = coluna_agrupamento
            
            # Se uma op√ß√£o foi selecionada, mostra o bot√£o Play
            if hasattr(st.session_state, 'opcao_selecionada'):
                st.success(f"Selecionado: {st.session_state.opcao_selecionada}")
                
                # Dados que ser√£o processados baseado no tipo de organiza√ß√£o
                if hasattr(st.session_state, 'tipo_organizacao') and st.session_state.tipo_organizacao.startswith("üèóÔ∏è Por Propriedade"):
                    # Filtrar por propriedade
                    ups_para_processar = df_sem_laudo[df_sem_laudo[st.session_state.coluna_agrupamento].isin(st.session_state.grupos_selecionados)]
                    colunas_exibir = ['UP', st.session_state.coluna_agrupamento, 'Ocorr√™ncia Predominante', 'Severidade Predominante', 'Incidencia']
                else:
                    # Filtrar por n√∫cleo (m√©todo original)
                    ups_para_processar = df_sem_laudo[df_sem_laudo['Nucleo'].isin(st.session_state.grupos_selecionados)]
                    colunas_exibir = ['UP', 'Nucleo', 'Ocorr√™ncia Predominante', 'Severidade Predominante', 'Incidencia']
                
                st.subheader("üìã Dados que ser√£o processados:")
                st.dataframe(ups_para_processar[colunas_exibir], use_container_width=True)
                
                # Se√ß√£o de Credenciais
                st.subheader("üîê Credenciais de Acesso")
                col1, col2 = st.columns(2)
                
                with col1:
                    email_partial_orig = st.text_input("üìß Email:", placeholder="seu.email", key="original_email", help="Digite apenas a parte antes do @. O @suzano.com.br ser√° adicionado automaticamente.")
                
                with col2:
                    senha_orig = st.text_input("üîí Senha:", type="password", placeholder="Sua senha", key="original_senha")
                
                if not email_partial_orig or not senha_orig:
                    st.warning("‚ö†Ô∏è Por favor, preencha email e senha para continuar.")
                    return
                
                # Concatenar automaticamente com @suzano.com.br
                email_completo_orig = f"{email_partial_orig}@suzano.com.br"
                
                # Bot√£o Play para iniciar
                if st.button("‚ñ∂Ô∏è INICIAR LAN√áAMENTO", key="play_button", type="primary", use_container_width=True):
                    # Verificar se √© continua√ß√£o de sess√£o
                    is_continuation = hasattr(st.session_state, 'browser_ativo') and st.session_state.browser_ativo
                    if is_continuation:
                        st.info("üîÑ Continuando com navegador aberto...")
                    
                    processar_lancamento_novo(ups_para_processar, st.session_state.grupos_selecionados, df, st.session_state.tipo_organizacao, st.session_state.coluna_agrupamento, email_completo_orig, senha_orig)
                    
        except Exception as e:
            st.error(f"Erro ao ler o arquivo: {str(e)}")

def processar_lancamento(df_ups, nucleos_selecionados, df_original):
    """Fun√ß√£o principal que processa o lan√ßamento usando o m√≥dulo lancamento_fenix"""
    try:
        st.info("üöÄ Iniciando processamento...")
        
        # Salvar DataFrame original no session_state para posterior atualiza√ß√£o
        st.session_state.df_original = df_original.copy()
        
        # Usar o m√≥dulo de automa√ß√£o (fun√ß√£o original sempre usa n√∫cleo)
        resultado = executar_lancamento_fenix(df_ups, nucleos_selecionados, "üè¢ Por N√∫cleo", None, None)
        
        if resultado:
            st.balloons()  # Anima√ß√£o de comemora√ß√£o
            
            # Verificar se deve mostrar op√ß√£o de continuar
            if hasattr(st.session_state, 'mostrar_continuar_lancamento') and st.session_state.mostrar_continuar_lancamento:
                st.success("üéâ N√∫cleo processado com sucesso!")
                st.info("üöÄ Pronto para processar outro n√∫cleo - use os bot√µes acima!")
            else:
                st.success("üéâ Processamento de todos os n√∫cleos conclu√≠do!")
            
        # NOVA FUNCIONALIDADE: Mostrar op√ß√£o de atualiza√ß√£o se houver UPs processadas com sucesso
        if hasattr(st.session_state, 'mostrar_opcao_excel') and st.session_state.mostrar_opcao_excel:
            ups_processadas = getattr(st.session_state, 'ups_processadas_com_sucesso', [])
            if ups_processadas:
                st.markdown("---")
                st.subheader("üìù Atualiza√ß√£o da Planilha")
                st.info(f"‚úÖ {len(ups_processadas)} UP(s) processada(s) com sucesso: {', '.join(ups_processadas)}")
                st.info("Deseja atualizar o status dessas UPs de 'N√ÉO' para 'SIM' na coluna 'Laudo Existente'?")
                
                # Debug: Mostrar informa√ß√µes sobre o DataFrame original
                if hasattr(st.session_state, 'df_original'):
                    df_info = st.session_state.df_original
                    total_nao = len(df_info[df_info['Laudo Existente'].str.upper() == 'N√ÉO'])
                    total_sim = len(df_info[df_info['Laudo Existente'].str.upper() == 'SIM'])
                    st.info(f"üìä Status atual da planilha: {total_nao} com 'N√ÉO', {total_sim} com 'SIM'")
                
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("‚úÖ SIM - Atualizar Status", key="atualizar_sim", type="primary"):
                        st.info("üîÑ Iniciando atualiza√ß√£o da planilha...")
                        
                        # Debug adicional: verificar dados no session_state
                        st.info(f"üîç DataFrame original shape: {st.session_state.df_original.shape}")
                        st.info(f"üîç UPs a serem atualizadas: {ups_processadas}")
                        st.info(f"üîç Tipo das UPs: {[type(up) for up in ups_processadas]}")
                        
                        try:
                            resultado_atualizacao = atualizar_status_planilha(st.session_state.df_original, ups_processadas)
                            
                            if resultado_atualizacao:
                                st.success("üìä Planilha atualizada com sucesso!")
                                st.success("üéâ Todas as UPs processadas com sucesso tiveram seu status atualizado para 'SIM'!")
                                st.info("üì• Use o bot√£o de download acima para baixar a planilha atualizada.")
                                
                                # Reset da op√ß√£o ap√≥s uso
                                st.session_state.mostrar_opcao_excel = False
                                st.rerun()  # For√ßar atualiza√ß√£o da interface
                            else:
                                st.error("‚ùå Erro ao atualizar a planilha ou nenhuma UP foi encontrada.")
                                st.error("üîç Verifique os logs de debug acima para entender o problema.")
                        except Exception as update_error:
                            st.error(f"‚ùå Erro durante atualiza√ß√£o: {str(update_error)}")
                            import traceback
                            st.error(f"‚ùå Stack trace completo: {traceback.format_exc()}")
                            
                with col2:
                    if st.button("‚ùå N√ÉO - Manter Original", key="atualizar_nao"):
                        st.info("‚úã Planilha mantida sem altera√ß√µes.")
                        # Reset da op√ß√£o ap√≥s uso
                        st.session_state.mostrar_opcao_excel = False
                        st.rerun()  # For√ßar atualiza√ß√£o da interface
                        
        if not resultado:
            st.error("‚ùå Houve erros durante o processamento. Verifique os logs acima.")
        
    except Exception as e:
        st.error(f"Erro durante o processamento: {str(e)}")

def processar_lancamento_novo(df_ups, grupos_selecionados, df_original, tipo_organizacao, coluna_agrupamento, email=None, senha=None):
    """
    Fun√ß√£o aprimorada que processa o lan√ßamento tanto por n√∫cleo quanto por propriedade
    """
    try:
        st.info("üöÄ Iniciando processamento...")
        
        # Salvar DataFrame original no session_state para posterior atualiza√ß√£o
        st.session_state.df_original = df_original.copy()
        
        # CORRE√á√ÉO: Debug do DataFrame original antes do processamento
        st.info(f"üîç DEBUG: DataFrame original salvo com {len(df_original)} linhas")
        st.info(f"üîç DEBUG: Colunas dispon√≠veis: {list(df_original.columns)}")
        if 'UP' in df_original.columns:
            ups_originais = df_original['UP'].unique()
            st.info(f"üîç DEBUG: Total de UPs √∫nicas no DataFrame original: {len(ups_originais)}")
            st.info(f"üîç DEBUG: Primeiras 10 UPs do DataFrame original: {list(ups_originais[:10])}")
        if 'Laudo Existente' in df_original.columns:
            status_counts = df_original['Laudo Existente'].value_counts()
            st.info(f"üîç DEBUG: Status na coluna 'Laudo Existente': {dict(status_counts)}")
        
        # Determinar se √© por propriedade ou por n√∫cleo e processar adequadamente
        if tipo_organizacao.startswith("üèóÔ∏è Por Propriedade"):
            st.info(f"üèóÔ∏è Processando por Propriedade usando coluna: {coluna_agrupamento}")
            
            # Para propriedades, precisamos filtrar o DataFrame pela propriedade selecionada
            # e depois simular como se fosse um n√∫cleo
            df_filtrado_por_propriedade = pd.DataFrame()
            
            for propriedade in grupos_selecionados:
                st.info(f"üìã Filtrando UPs da propriedade: {propriedade}")
                ups_desta_propriedade = df_ups[df_ups[coluna_agrupamento] == propriedade]
                st.info(f"üìä Encontradas {len(ups_desta_propriedade)} UPs para propriedade {propriedade}")
                df_filtrado_por_propriedade = pd.concat([df_filtrado_por_propriedade, ups_desta_propriedade], ignore_index=True)
            
            # Agora vamos criar um "n√∫cleo simulado" para cada propriedade
            # Modificar temporariamente a coluna "Nucleo" para conter o nome da propriedade
            df_para_processamento = df_filtrado_por_propriedade.copy()
            
            # Para cada propriedade selecionada, substituir o valor da coluna "Nucleo" 
            # pelo nome da propriedade para que o sistema de automa√ß√£o funcione
            for propriedade in grupos_selecionados:
                mask = df_para_processamento[coluna_agrupamento] == propriedade
                df_para_processamento.loc[mask, 'Nucleo'] = propriedade
            
            resultado = executar_lancamento_fenix(df_para_processamento, grupos_selecionados, tipo_organizacao, email, senha)
        
        else:
            st.info("üè¢ Processando por N√∫cleo (m√©todo original)")
            resultado = executar_lancamento_fenix(df_ups, grupos_selecionados, tipo_organizacao, email, senha)
        
        if resultado:
            st.balloons()  # Anima√ß√£o de comemora√ß√£o
            
            # Verificar se deve mostrar op√ß√£o de continuar
            if hasattr(st.session_state, 'mostrar_continuar_lancamento') and st.session_state.mostrar_continuar_lancamento:
                if tipo_organizacao.startswith("üèóÔ∏è Por Propriedade"):
                    st.success("üéâ Propriedade processada com sucesso!")
                    st.info("üöÄ Pronto para processar outra propriedade - use os bot√µes acima!")
                else:
                    st.success("üéâ N√∫cleo processado com sucesso!")
                    st.info("üöÄ Pronto para processar outro n√∫cleo - use os bot√µes acima!")
            else:
                if tipo_organizacao.startswith("üèóÔ∏è Por Propriedade"):
                    st.success("üéâ Processamento de todas as propriedades conclu√≠do!")
                else:
                    st.success("üéâ Processamento de todos os n√∫cleos conclu√≠do!")
            
        # Funcionalidade de atualiza√ß√£o da planilha (mantida igual)
        if hasattr(st.session_state, 'mostrar_opcao_excel') and st.session_state.mostrar_opcao_excel:
            ups_processadas = getattr(st.session_state, 'ups_processadas_com_sucesso', [])
            
            # CORRE√á√ÉO: Debug das UPs processadas
            st.info(f"üîç DEBUG: UPs registradas como processadas: {ups_processadas}")
            st.info(f"üîç DEBUG: Tipo de organiza√ß√£o usado: {tipo_organizacao}")
            st.info(f"üîç DEBUG: Grupos selecionados: {grupos_selecionados}")
            if ups_processadas:
                st.markdown("---")
                st.subheader("üìù Atualiza√ß√£o da Planilha")
                st.info(f"‚úÖ {len(ups_processadas)} UP(s) processada(s) com sucesso: {', '.join(ups_processadas)}")
                st.info("Deseja atualizar o status dessas UPs de 'N√ÉO' para 'SIM' na coluna 'Laudo Existente'?")
                
                # Debug: Mostrar informa√ß√µes sobre o DataFrame original
                if hasattr(st.session_state, 'df_original'):
                    df_info = st.session_state.df_original
                    total_nao = len(df_info[df_info['Laudo Existente'].str.upper() == 'N√ÉO'])
                    total_sim = len(df_info[df_info['Laudo Existente'].str.upper() == 'SIM'])
                    st.info(f"üìä Status atual da planilha: {total_nao} com 'N√ÉO', {total_sim} com 'SIM'")
                
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("‚úÖ SIM - Atualizar Status", key="atualizar_sim_novo", type="primary"):
                        st.info("üîÑ Iniciando atualiza√ß√£o da planilha...")
                        
                        try:
                            resultado_atualizacao = atualizar_status_planilha(st.session_state.df_original, ups_processadas)
                            
                            if resultado_atualizacao:
                                st.success("üìä Planilha atualizada com sucesso!")
                                st.success("üéâ Todas as UPs processadas com sucesso tiveram seu status atualizado para 'SIM'!")
                                st.info("üì• Use o bot√£o de download acima para baixar a planilha atualizada.")
                                
                                # Reset da op√ß√£o ap√≥s uso
                                st.session_state.mostrar_opcao_excel = False
                                st.rerun()
                            else:
                                st.error("‚ùå Erro ao atualizar a planilha ou nenhuma UP foi encontrada.")
                        except Exception as update_error:
                            st.error(f"‚ùå Erro durante atualiza√ß√£o: {str(update_error)}")
                            import traceback
                            st.error(f"‚ùå Stack trace completo: {traceback.format_exc()}")
                            
                with col2:
                    if st.button("‚ùå N√ÉO - Manter Original", key="atualizar_nao_novo"):
                        st.info("‚úã Planilha mantida sem altera√ß√µes.")
                        # Reset da op√ß√£o ap√≥s uso
                        st.session_state.mostrar_opcao_excel = False
                        st.rerun()
                        
        if not resultado:
            st.error("‚ùå Houve erros durante o processamento. Verifique os logs acima.")
        
    except Exception as e:
        st.error(f"Erro durante o processamento: {str(e)}")
        import traceback
        st.error(f"Stack trace: {traceback.format_exc()}")

def lancamento_fenix_hard():
    """Interface para Lan√ßamento Autom√°tico no F√™nix (Hard Mode)"""
    st.header("üöÄ Lan√ßamento F√™nix Hard - Modo Autom√°tico")
    st.info("üí™ Este modo processa automaticamente todas as propriedades selecionadas sem interven√ß√£o do usu√°rio.")
    
    # Upload do arquivo Excel
    uploaded_file = st.file_uploader("Escolha um arquivo Excel", type=['xlsx', 'xls'], key="hard_excel_uploader")
    
    if uploaded_file is not None:
        try:
            # L√™ o arquivo Excel
            df = pd.read_excel(uploaded_file)
            st.success(f"‚úÖ Arquivo carregado com sucesso! {len(df)} linhas encontradas.")
            
            # Verifica colunas necess√°rias e normaliza nomes
            required_columns = ['UP', 'UNF', 'Idade', 'Ocorr√™ncia Predominante', 'Severidade Predominante', 'Incidencia', 'Laudo Existente']
            
            # Verificar se existe coluna de propriedade (aceitar varia√ß√µes)
            propriedade_col = None
            for col in df.columns:
                if col.lower() in ['propriedade', 'property']:
                    propriedade_col = col
                    break
            
            if propriedade_col is None:
                st.error("‚ùå Coluna de propriedade n√£o encontrada. Procurando por: 'propriedade', 'Propriedade', 'property'")
                st.info("üìã Colunas dispon√≠veis no arquivo:")
                st.write(list(df.columns))
                return
            
            # Normalizar nome da coluna de propriedade
            if propriedade_col != 'Propriedade':
                df = df.rename(columns={propriedade_col: 'Propriedade'})
                st.success(f"‚úÖ Coluna '{propriedade_col}' renomeada para 'Propriedade'")
            
            # Verificar outras colunas obrigat√≥rias
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                st.info("üìã Colunas dispon√≠veis no arquivo:")
                st.write(list(df.columns))
                return
            
            # Filtrar apenas registros sem laudo
            df_sem_laudo = df[df['Laudo Existente'].str.upper() == 'N√ÉO'].copy()
            
            if len(df_sem_laudo) == 0:
                st.warning("‚ö†Ô∏è N√£o h√° registros sem laudo para processar.")
                return
            
            st.success(f"üìä {len(df_sem_laudo)} UPs sem laudo encontradas para processamento.")
            
            # Se√ß√£o de Credenciais
            st.subheader("üîê Credenciais de Acesso")
            col1, col2 = st.columns(2)
            
            with col1:
                email_partial = st.text_input("üìß Email:", placeholder="seu.email", key="hard_email", help="Digite apenas a parte antes do @. O @suzano.com.br ser√° adicionado automaticamente.")
            
            with col2:
                senha = st.text_input("üîí Senha:", type="password", placeholder="Sua senha", key="hard_senha")
            
            if not email_partial or not senha:
                st.warning("‚ö†Ô∏è Por favor, preencha email e senha para continuar.")
                return
            
            # Concatenar automaticamente com @suzano.com.br
            email_completo = f"{email_partial}@suzano.com.br"
            
            # Sele√ß√£o de UNF
            st.subheader("üè¢ Sele√ß√£o de UNF")
            unfs_disponveis = sorted(df_sem_laudo['UNF'].unique())
            
            if len(unfs_disponveis) == 0:
                st.error("‚ùå Nenhuma UNF encontrada nos dados.")
                return
            
            unf_selecionada = st.selectbox("Selecione a UNF:", unfs_disponveis, key="hard_unf_select")
            
            if unf_selecionada:
                # Mostrar propriedades dispon√≠veis para a UNF selecionada
                st.subheader(f"üèóÔ∏è Propriedades da UNF {unf_selecionada}")
                
                propriedades_info = obter_propriedades_por_unf(df_sem_laudo, unf_selecionada)
                
                if not propriedades_info:
                    st.warning(f"‚ö†Ô∏è Nenhuma propriedade encontrada para UNF {unf_selecionada}")
                    return
                
                # Mostrar propriedades em formato de tabela
                propriedades_df = pd.DataFrame([
                    {"Propriedade": prop, "Quantidade de UPs": qtd}
                    for prop, qtd in propriedades_info.items()
                ])
                
                st.dataframe(propriedades_df, use_container_width=True)
                
                # Sele√ß√£o m√∫ltipla de propriedades
                st.subheader("‚úÖ Sele√ß√£o de Propriedades")
                todas_propriedades = list(propriedades_info.keys())
                
                # Op√ß√£o de selecionar todas
                if st.checkbox("üéØ Selecionar todas as propriedades", key="hard_select_all"):
                    propriedades_selecionadas = todas_propriedades
                else:
                    propriedades_selecionadas = st.multiselect(
                        "Escolha as propriedades para processar:",
                        todas_propriedades,
                        key="hard_propriedades_select"
                    )
                
                if propriedades_selecionadas:
                    # Mostrar resumo
                    total_ups = sum(propriedades_info[prop] for prop in propriedades_selecionadas)
                    
                    st.success(f"üìã Resumo da Sele√ß√£o:")
                    st.info(f"üèóÔ∏è {len(propriedades_selecionadas)} propriedades selecionadas")
                    st.info(f"üìä {total_ups} UPs ser√£o processadas")
                    st.info(f"üè¢ UNF: {unf_selecionada}")
                    
                    # Lista das propriedades selecionadas
                    st.write("**Propriedades selecionadas:**")
                    for prop in propriedades_selecionadas:
                        st.write(f"‚Ä¢ {prop} ({propriedades_info[prop]} UPs)")
                    
                    # Bot√£o para iniciar processamento
                    st.markdown("---")
                    
                    # Aviso importante
                    st.warning("‚ö†Ô∏è **ATEN√á√ÉO**: O modo Hard √© totalmente autom√°tico. Uma vez iniciado, o sistema processar√° todas as propriedades selecionadas sem parar para confirma√ß√µes.")
                    
                    col_btn1, col_btn2 = st.columns(2)
                    
                    with col_btn1:
                        if st.button("üöÄ INICIAR PROCESSAMENTO AUTOM√ÅTICO", type="primary", key="hard_start_processing", use_container_width=True):
                            st.info("üéØ Iniciando processamento autom√°tico...")
                            
                            # Validar novamente as credenciais
                            if not email_completo or not senha:
                                st.error("‚ùå Email e senha s√£o obrigat√≥rios!")
                                return
                            
                            # Executar processamento
                            with st.status("üîÑ Processando todas as propriedades...", expanded=True) as status:
                                resultado = executar_lancamento_fenix_hard(
                                    df_sem_laudo, 
                                    email_completo, 
                                    senha, 
                                    unf_selecionada, 
                                    propriedades_selecionadas
                                )
                                
                                if resultado:
                                    status.update(label="‚úÖ Processamento conclu√≠do com sucesso!", state="complete", expanded=False)
                                    st.balloons()
                                    st.success("üéâ Todas as propriedades foram processadas automaticamente!")
                                else:
                                    status.update(label="‚ùå Processamento conclu√≠do com erros", state="error", expanded=True)
                                    st.error("üí• Houve erros durante o processamento. Verifique os logs acima.")
                    
                    with col_btn2:
                        if st.button("üìã Visualizar Dados", key="hard_preview_data", use_container_width=True):
                            st.subheader("üëÄ Pr√©via dos Dados que Ser√£o Processados")
                            
                            # Filtrar dados pelas propriedades selecionadas
                            dados_preview = df_sem_laudo[
                                (df_sem_laudo['UNF'] == unf_selecionada) & 
                                (df_sem_laudo['Propriedade'].isin(propriedades_selecionadas))
                            ]
                            
                            colunas_preview = ['UP', 'Propriedade', 'Ocorr√™ncia Predominante', 'Severidade Predominante', 'Incidencia', 'Idade']
                            st.dataframe(dados_preview[colunas_preview], use_container_width=True)
                            
                else:
                    st.info("üëÜ Selecione pelo menos uma propriedade para continuar.")
                    
        except Exception as e:
            st.error(f"‚ùå Erro ao processar o arquivo: {str(e)}")
            st.error(f"üîç Detalhes: {traceback.format_exc()}")

def criar_pdf():
    # Chama a fun√ß√£o do m√≥dulo cria_pdf.py
    criar_pdf_streamlit()

def main():
    st.title("Sistema de Automa√ß√£o RPA")
    
    # Inicializar flags do session_state
    if 'mostrar_opcao_excel' not in st.session_state:
        st.session_state.mostrar_opcao_excel = False
    
    if 'mostrar_continuar_lancamento' not in st.session_state:
        st.session_state.mostrar_continuar_lancamento = False
    
    if 'browser_ativo' not in st.session_state:
        st.session_state.browser_ativo = False
    
    # Criando o menu lateral
    st.sidebar.title("Menu de Op√ß√µes")
    opcao = st.sidebar.radio(
        "Selecione a opera√ß√£o desejada:",
        ["Lan√ßamento no F√™nix", "Lan√ßamento F√™nix Hard", "Criar PDF com Imagens e Croquis"],
        key="menu_principal"
    )
    
    # Mostrar status do navegador na sidebar se estiver ativo
    if st.session_state.browser_ativo:
        st.sidebar.success("üåê Navegador Ativo")
        if st.sidebar.button("üîö Fechar Navegador", key="sidebar_fechar"):
            if fechar_navegador_manual():
                st.success("‚úÖ Navegador fechado!")
                time.sleep(1)
                st.rerun()
    
    # Navega√ß√£o baseada na escolha do usu√°rio
    if opcao == "Lan√ßamento no F√™nix":
        lancamento_fenix()
    elif opcao == "Lan√ßamento F√™nix Hard":
        lancamento_fenix_hard()
    else:
        criar_pdf()

if __name__ == "__main__":
    main()
